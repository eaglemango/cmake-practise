# Семинарское задание 3
# Выполнил: Горбунов Сергей

## Часть 1

Сначала репозиторий был скопирован на компьютер:

```
$ git clone https://github.com/akhtyamovpavel/PatternsCollection.git
```

Я не стал долго ждать и решил сразу собрать проект, однако всё оказалось не так просто:

```
$ cmake

[skipped]

  Unable to find the Boost header files.  Please set BOOST_ROOT to the root
  directory containing Boost or BOOST_INCLUDEDIR to the directory containing
  Boost's headers.
Call Stack (most recent call first):
  Adapter/cpp-source/CMakeLists.txt:10 (find_package)

[skipped]
```

Ничего страшного,  установить `Boost` было несложно (скачал архив с официального сайта и распаковал содержимое в `/usr/local/boost_1_67_0/`). Попробуем собраться ещё раз. 

К сожалению, и эта попытка не увенчалась успехом: `cmake` не смог найти `boost_system` (текст ошибки утерян). Всё в порядке, просто возьмем и соберем то, что от нас хотят:

```
$ cd /usr/local/boost_1_67_0/
$ ./bootstrap.sh --with-libraries=system
$ ./b2 install
```

После этого `cmake` наконец-то отработал без ошибок.

Время `make`! Ладно, тоже не всё сразу. Сначала сборка прекратилась из-за отсутствия файла `Decorator/configs/config.ini`. После его создания всплыла ещё одна ошибка: 

```
-- Build type: Debug
-- Checking for module 'libgsasl'
--   No package 'libgsasl' found
-- Could NOT find GSASL (missing: GSASL_LIBRARIES GSASL_INCLUDE_DIR) 
-- Could NOT find GnuTLS (missing: GNUTLS_LIBRARY GNUTLS_INCLUDE_DIR) 
-- Could NOT find Doxygen (missing: DOXYGEN_EXECUTABLE) 
CMake Error at CMakeLists.txt:1004 (MESSAGE):
  Enabling Sendmail protocol requires that you specify path to 'sendmail'
  binary.
```

Исправляем это недоразумение:

```
$ sudo apt-get install libgsasl7-dev
$ sudo apt-get install gnutls-dev
$ sudo apt-get install doxygen
```

Видимо, программисты - это не те люди, которым живётся хорошо и спокойно:

```
Enabling Sendmail protocol requires that you specify path to 'sendmail'
  binary.
```

Покажем, где именно лежит бинарник `sendmail` (редактируем `CMakeLists.txt` в директории `Decorator`):

```
ExternalProject_Add(
        vmime_project
        GIT_REPOSITORY https://github.com/kisli/vmime
        ... -DVMIME_SENDMAIL_PATH=/usr/sbin/sendmail
)
```

Ничто так не радует человека, как успех при выполнении `make`. Правда, почему-то исполняемые файлы оказались директорией выше в папке `bin`, а библитотеки там же, но в папке `lib`. 

Далее осталось сделать так, чтобы эта красота работала и под Raspberry Pi. На официальной странице проекта на GitHub открываем репозиторий `tools`. Для выполнения задания было бы достаточно скачать `tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/`, однако в `git` возможность скачать отдельную папку из репозитория присутствует только с версии `2.19`, а для моего дистрибутива самая свежая версия оказалась `2.17.1` (`git --version`). Пришлось скачивать весь репозиторий. 

```
$ git clone https://github.com/raspberrypi/tools.git
```

Настал тот час!

```
$ cmake -DON_PI=ON

Compiling on Pi
CMake Error at CMakeLists.txt:11 (message):
  Need sysroot for compiling
```

Ладно, не настал. Укажем значение переменной `SYSROOT` (редактируем главный файл `CMakeLists.txt`):

```
...

option(ON_PI "Build on PI" OFF)

set(SYSROOT "../malinka/tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin")

...
```

Другое дело! `cmake` и последующий `make` отработали, как по маслу. Там же, где лежали папки `bin` и `lib` появились папки `bin-arm` и `lib-arm`. Внутри этих папок лежит то, что нам нужно (к примеру, нет `Adapter`, `Composite` и `Decorator`, поскольку в `CMakeLists.txt` указано, что если флаг `ON_PI` в состоянии `ON`, то собирать упомянутые вещи не требуется).

_Небольшое замечание_. Не обязательно было вписывать `SYSROOT` и `VMIME_SENDMAIL_PATH` в файлы (я сделал это для своего удобства). Достаточно было бы указать их в качестве аргументов при запуске `cmake` так же, как я сделал с `ON_PI` чуть выше.

---

## Часть 2

Путь к успеху начался с создания почты на `GMail`. К сожалению, гладко всё не получилось: сервис требовал номер телефона. После нескольких попыток и перебора нескольких устройств, почта всё-таки была создана. 

После создания почты была проведена процедура `Google Unlock Captcha`, а также открыт доступ к аккаунуту сторонним приложениям (вкладка "Безопасность" в настройках аккаунта `Google`).

В мессенджере `Telegram` были созданы: бот `@yoursuperpersonalbot` (не без помощи самого `@BotFather`) и канал `@thisisthebestpeoplechannel` (задача тривиальная). Ещё созданный бот был добавлен в канал в качестве админа.

Для получения `chatid` созданного канала пришлось немного поработать с `Bot API`. Как известно, по следующему запросу

```
https://api.telegram.org/bot%token/getUpdates
``` 

где `%token` - это токен нашего бота, можно получить список сообщений, пришедших боту. Заранее написав что-то в канал, мы с помощью этой процедуры получим требуемую информацию.

Однако, я сделал это с помощью браузера, хотя по заданию требуется использование `curl`. Никаких проблем, аналогичную процедуру можно сделать и с этой утилитой:

```
$ curl https://api.telegram.org/bot%token/getUpdates
```

Все требуемые данные были записаны в файл `config.ini`. В качестве "принимающей" почты был указан личный адрес, поскольку требовалось выяснить работоспособность программы `Decorator` после сборки проекта.

Однако встретилась не очень приятная проблема: к серверам Telegram доступ получить просто так нельзя. Хорошо, что у нас с другом имеется под рукой сервер в Германии, который быстро превратился в устройство по обходу блокировки.

Зайдя в папку с готовыми бинарниками и запустив `./Decorator`, я получил следующий результат:

1. `email notifier` сработал корректно: на мой личный адрес пришло письмо с специально созданного ящика
2. `telegram notifier` тоже отработал без проблем: бот написал сообщение в канал

Процитирую:

> Hello, TP

Если посмотреть, что творится в канале, то можно увидеть много сообщений от бота. Дело в том, что я опустил момент, когда кучу раз ловил ошибку при авторизации бота на почте. Я долго не мог понять в чём проблема и даже начал винить во всём свои руки, но оказалось, что большой брат очень заботливо не давал пройти авторизацию даже после `Unlock Captcha`. Пришлось дополнительно в настройках аккаунта разрешать доступ сторонним приложениям (выше я об этом написал).

## Пояснения к скриптам

`pc/run-pc.sh` - запускает бинарники собранного под PC проекта

`raspberry/run-raspberry.sh` - запускает бинарники собранного под Raspberry Pi проекта

`build-pc.sh` - с нуля собирает проект под PC и запускает его

`build-raspberry.sh` - с нуля собирает проект под Raspberry Pi и запускает его

Если требуется проверить работоспособность двух первых скриптов без сборки проекта с нуля, то в папках `pc` и `raspberry` лежат архивы, содержащие в себе уже готовые для запуска файлы:

```
$ unzip ./for-raspberry.zip
$ ./run-raspberry.sh
```

Скрипты для сборки с нуля подразумевают, что они бы сработали у меня на компьютере на момент начала работы с заданием. Корректность работы у других людей гарантировать нельзя.
